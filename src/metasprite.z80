;
; generic metasprite engine for GB
;
; Copyright 2018 Damian Yerrick
;
; This software is provided 'as-is', without any express or implied
; warranty.  In no event will the authors be held liable for any damages
; arising from the use of this software.
; 
; Permission is granted to anyone to use this software for any purpose,
; including commercial applications, and to alter it and redistribute it
; freely, subject to the following restrictions:
; 
; 1. The origin of this software must not be misrepresented; you must not
;    claim that you wrote the original software. If you use this software
;    in a product, an acknowledgment in the product documentation would be
;    appreciated but is not required.
; 2. Altered source versions must be plainly marked as such, and must not be
;    misrepresented as being the original software.
; 3. This notice may not be removed or altered from any source distribution.
;
include "src/hardware.inc"
include "src/global.inc"

TMARGIN = 16
LMARGIN = 8
SPRITEHT = 8
SPRITEWID = 8

; args
  rsset hLocals
hmsprYLo rb 1
hmsprYHi rb 1
hmsprXLo rb 1
hmsprXHi rb 1
hmsprAttr rb 1
hmsprSheetID rb 1
hmsprFrame rb 1
hmsprBaseTile rb 1
global hmsprYLo, hmsprYHi, hmsprXLo, hmsprXHi
global hmsprAttr, hmsprSheetID, hmsprFrame, hmsprBaseTile


; internal
hmsprYAdd rb 1
hmsprXAdd rb 1
hmsprStripY rb 1
hmsprStripXLo rb 1
hmsprStripXHi rb 1

section "metasprite", ROM0

draw_metasprite::
  ldh a,[hmsprAttr]
  ld c,a  ; C = flip flags

  ; Correct coordinates for offset binary representation.
  ; Not correcting for Y flip until a Y flip is needed in a game.
  ldh a,[hmsprYLo]
  sub 128-TMARGIN
  ldh [hmsprYLo],a
  ldh a,[hmsprYHi]
  sbc 0
  ldh [hmsprYHi],a

  ; Convert X coordintes and set increase direction for X flip
  ld b,128-LMARGIN
  ld a,SPRITEWID
  bit OAMB_XFLIP,c
  jr z,.noxcoordflipcorrect
    ld b,127+SPRITEWID-LMARGIN
    ld a,-SPRITEWID
  .noxcoordflipcorrect:
  ldh [hmsprXAdd],a
  ldh a,[hmsprXLo]
  sub b
  ldh [hmsprXLo],a
  ldh a,[hmsprXHi]
  sbc 0
  ldh [hmsprXHi],a

  ; Look up metasprite address for this cel
  ld de,sheet_msprtables
  ldh a,[hmsprSheetID]
  call de_index_a
  ld d,h
  ld e,l
  ldh a,[hmsprFrame]
  call de_index_a

  ; Load destination address
  ld de,oam_used
  ld a,[de]
  ld e,a
  .rowloop:
    ; Invariants here:
    ; DE is multiple of 4 and within shadow OAM
    ; HL at start of sprite strip
    ; C equals [hmsprAttr], not modified by a strip

    ; Load Y strip offset
    ld a,[hl+]
    or a  ; Y=0 (that is, -128) terminates cel
    ret z
    bit OAMB_YFLIP,c
    jr z,.noystripflipcorrect
      cpl
    .noystripflipcorrect:
    ld b,a
    ldh a,[hmsprYLo]
    add b
    ld b,a
    ldh a,[hmsprYHi]
    adc 0
    jr nz,.strip_below_screen
    ld a,b
    cp TMARGIN+1-SPRITEHT
    jr c,.strip_below_screen
    cp SCRN_Y+TMARGIN
    jr c,.strip_within_y_range
    .strip_below_screen:
      inc hl  ; skip X position
      ld a,[hl+]  ; load length and attributes
      and $E0  ; strip PVH bits contain width-1
      rlca
      rlca
      rlca
      inc a
      add l
      ld l,a
      jr nc,.rowloop
      inc h
      jr .rowloop
    .strip_within_y_range:
    ldh [hmsprStripY],a

    ; Load X strip offset
    ld a,[hl+]
    bit OAMB_XFLIP,c
    jr z,.noxstripflipcorrect
      cpl
    .noxstripflipcorrect:
    ld b,a
    ldh a,[hmsprXLo]
    add b
    ldh [hmsprStripXLo],a
    ldh a,[hmsprXHi]
    adc 0
    ldh [hmsprStripXHi],a

    ; Third byte of strip is palette and length
    ; 7654 3210
    ; |||| |+++- GBC palette ID
    ; |||| +---- GBC bank ID
    ; |||+------ DMG palette ID
    ; +++------- Length
    ld a,[hl]
    and $1F
    xor c
    ld c,a
    ld a,[hl+]
    and $E0  ; strip PVH bits contain width-1
    rlca
    rlca
    rlca
    inc a
    ld b,a

    ; Copy sprites to OAM
    .spriteloop:
      push bc  ; sprite count and strip attribute
      ld a,[hmsprStripY]
      ld [de],a

      ; Only resulting X locations in 1-167 are in range
      ld a,[hmsprStripXHi]
      or a
      jr nz,.skip_one_tile
      ld a,[hmsprStripXLo]
      or a
      jr z,.skip_one_tile
      cp SCRN_X+LMARGIN
      jr nc,.skip_one_tile

      ; We're in range, and Y is already written.
      ; Acknowledge writing Y, and write X, tile, and attribute
      inc e
      ld [de],a
      inc e
      ld a,[hl]
      and $3F
      ld b,a
      ld a,[hmsprBaseTile]
      add b
      ld [de],a
      inc e
      ld a,[hl]
      and $C0  ; combine with tile flip attribute
      rrca
      xor c
      ld [de],a
      inc e
      
    .skip_one_tile:
      ld a,[hmsprXAdd]
      ld b,a
      ld a,[hmsprStripXLo]
      add b
      ld [hmsprStripXLo],a
      ld a,[hmsprStripXHi]
      add 0
      bit 7,b
      jr z,.anoneg
        dec a
      .anoneg:
      ld [hmsprStripXHi],a
      pop bc
      inc hl
      dec b
      jr nz,.spriteloop
    ld a,e
    ld [oam_used],a
    ld a,[hmsprAttr]
    ld c,a
    jp .rowloop

sheet_msprtables:
  dw Libbet_mspraddrs

Libbet_mspraddrs:
  include "obj/gb/Libbet.z80"