include "src/hardware.inc"
include "src/global.inc"

section "movevars", WRAM0
cur_facing: ds 1

section "main", ROM0

timer_handler::
serial_handler::
joypad_handler::
  reti

main::
  ; Set up vblank handler
  ld a,IEF_VBLANK
  ldh [rIE],a  ; enable IRQs
  xor a
  ldh [rIF],a  ; Acknowledge any pending IRQs
  ld [nmis],a
  ei

  call do_instructions

  call lcd_off
  call load_floor_chr
  call load_statusbar_chr
  ld hl,CHRRAM0
  ld de,Libbet_pb16
  ld b,40
  call pb16_unpack_block
  ld bc,2
  call srand
  call run_dma  ; shut up BGB

another_floor:
  ; Generate the floor
  ld a,6
  ld [floor_width],a
  ld a,4
  ld [floor_height],a
  call make_good_floor
  xor a
  ld [cur_score],a
  ld a,2
  ld [cur_facing],a
  call place_exit

  call lcd_off

  ; Clear the map
  ld de,_SCRN0
  ld bc,32*16
  ld h,$6F  ; background tile
  call memset
  call draw_whole_floor
  call cursor_to_home
  call draw_floor_border
  call prepare_exit_door
  call write_hDrawCell
  call draw_statusbar_tilemap

  ld a,%00011011
  ldh [rBGP],a
  ld a,%00011111
  ldh [rOBP0],a
  ld a,LCDCF_ON|LCDCF_BG9800|LCDCF_BG8800|LCDCF_BGON|LCDCF_OBJON
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a

forever:
  xor a
  ld [oam_used],a

  ; Draw plain cursor
  ld a,[cursor_y]
  swap a
  ld b,a
  ld a,[floor_height]
  cp 8
  cpl  ; 2: FD+C; 4: FB+C; 6: F9+C; 7: F8+C; 8: F7+NC
  adc 9  ; 2: 7; 4: 5; 6: 3; 7: 2; 8: 0
  add a
  add a
  add a
  add b
  add 12
  ldh [hmsprYLo],a

  ld a,[cursor_x]
  swap a
  ld b,a
  ld a,[floor_width]
  cpl  ; 2: FD; 4: FB; 6: F9; 8: F7
  add 9  ; 2: 6; 4: 4; 6: 2; 7: 1; 8: 0
  add a
  add a
  add a
  add b
  add 24
  ldh [hmsprXLo],a

  ld a,[cur_facing]
  ld de,Libbet_facing_to_frame
  call de_index_a
  ld a,l
  ldh [hmsprAttr],a
  ld a,h
  ldh [hmsprFrame],a

  xor a
  ldh [hmsprXHi],a
  ldh [hmsprYHi],a

  ld a,$00
  ldh [hmsprSheetID],a
  ldh [hmsprBaseTile],a
  call draw_metasprite

  call lcd_clear_oam

  call wait_vblank_irq
  call run_dma
  call write_hDrawCell
  call write_pctage

  call read_pad

  ; Sitting on a dead end after last move?
  call floor_read_at_cursor
  bit 2,a
  jr z,.not_on_deadend
    set 3,a
    call prepare_hDrawCell
    call cursor_to_home
    jr .notmove
  .not_on_deadend:

  call check_exit_pct
  jr nc,.exit_not_opened
    call prepare_exit_door
    jr .notmove
  .exit_not_opened:

  ld a,[new_keys]
  ld b,a
  and PADF_RIGHT|PADF_LEFT|PADF_UP|PADF_DOWN
  jr z, .notmove
    ld c,$FF
    swap a
    .ctzloop:
      inc c
      rra
      jr nc,.ctzloop
    ld a,c
    ld [cur_facing],a  ; Face the pressed direction
    ld a,[cur_keys]
    bit PADB_A,a  ; key A
    jr z,.notjump
      set 2,c  ; mark
    .notjump:
    push bc
    ld a,c
    call is_valid_move
    pop bc
    jr c,.is_valid_move

      ; Check whether it's a roll up from the top row
      ; while the exit is open
      ld a,2  ; roll up
      xor c
      jr nz,.notmove
      call check_exitable_cell
      jr nc,.notmove
      jp another_floor
    .is_valid_move:
    ; A: 1 for color change (possibly scoring); 0 for not
    ; C: move attempted; E[5:3]: new Y; E[2:0]: new X;
    ; HL: pointer to destination cell
    or a
    jr z,.move_to_cell_e
      push de
      push hl

      ; Get which track bit corresponds to this move ID
      ld a,c
      and $03
      ld b,a
      inc b
      ld a,$08
      .shlloop:
        rla
        dec b
        jr nz,.shlloop
      ld b,a

      ; See if that track bit is set
      call floor_read_at_cursor
      ld a,[hl]
      cpl
      and b
      jr z,.already_have_track_bit
        or [hl]
        ld [hl],a
        ld hl,cur_score
        inc [hl]
        call prepare_hDrawCell
        call prepare_pctage
      .already_have_track_bit:

      pop hl
      pop de

      ; Mark as entered
      set 3,[hl]
    .move_to_cell_e:
    ld a,e
    rra
    rra
    rra
    and $07
    ld [cursor_y],a
    ld a,e
    and $07
    ld [cursor_x],a
  .notmove:

  if SELECT_RESTARTS
  ld a,[new_keys]
  bit PADB_SELECT, a
  jp nz,another
  endc

  jp forever


Libbet_pb16:
  incbin "obj/gb/Libbet.chrgb.pb16"

Libbet_facing_to_frame:
  dw $0E00, $0E20, $1C00, $0000
