include "src/hardware.inc"
include "src/global.inc"

section "main", ROM0

timer_handler::
serial_handler::
joypad_handler::
  reti

main::
  ; Set up vblank handler
  ld a,IEF_VBLANK
  ldh [rIE],a  ; enable IRQs
  xor a
  ldh [rIF],a  ; Acknowledge any pending IRQs
  ld [nmis],a
  ei

  call do_instructions

  call lcd_off
  call load_floor_chr
  call load_statusbar_chr
  ld hl,CHRRAM0
  ld de,Libbet_pb16
  ld b,40
  call pb16_unpack_block
  ld bc,2
  call srand
  call run_dma  ; shut up BGB

another_floor:
  ; Generate the floor
  ld a,6
  ld [floor_width],a
  ld a,4
  ld [floor_height],a
  call make_good_floor
  xor a
  ld [cur_score],a
  call place_exit

  call lcd_off

  ; Clear the map
  ld de,_SCRN0
  ld bc,32*16
  ld h,$6F  ; background tile
  call memset
  call draw_whole_floor
  call cursor_to_home
  call init_player_pos
  call draw_floor_border
  call prepare_exit_door
  call write_hDrawCell
  call draw_statusbar_tilemap

  ld a,%00011011
  ldh [rBGP],a
  ld a,%00011111
  ldh [rOBP0],a
  ld a,LCDCF_ON|LCDCF_BG9800|LCDCF_BG8800|LCDCF_BGON|LCDCF_OBJON
  ld [vblank_lcdc_value],a
  ldh [rLCDC],a

forever:
  call move_player_anim
  xor a
  ld [oam_used],a
  call draw_player
  call lcd_clear_oam

  call wait_vblank_irq
  call run_dma
  call write_hDrawCell
  call write_pctage


  call read_pad

  ; this will have to be converted to a "dirty" queue
  call check_exit_pct
  jr nc,.exit_not_opened
    call prepare_exit_door
    jr .not_begin_move
  .exit_not_opened:

  call player_can_start_roll
  jr z,.not_begin_move

    ; cursor Y = 255 means Libbet is on the exit door
    ld a,[cursor_y]
    inc a
    jp z,another_floor

    ; Sitting on a dead end after last move?
    call floor_read_at_cursor
    bit 2,a
    jr z,.not_on_deadend
      set 3,a
      call prepare_hDrawCell
      call cursor_to_home
      call init_player_pos
      jr .not_begin_move
    .not_on_deadend:

    call try_move
  .not_begin_move:

  if SELECT_RESTARTS
  ld a,[new_keys]
  bit PADB_SELECT, a
  jp nz,another_floor
  endc

  jp forever

try_move:
  ld a,[cur_keys]
  ld b,a
  and PADF_RIGHT|PADF_LEFT|PADF_UP|PADF_DOWN
  ret z

  ld c,$FF
  swap a
  .ctzloop:
    inc c
    rra
    jr nc,.ctzloop
  ld a,c
  ld [cursor_facing],a  ; Face the pressed direction

  ld a,[cur_keys]
  bit PADB_A,a  ; key A
  jr z,.notjump
    set 2,c  ; mark
  .notjump:
  push bc
  ld a,c
  call is_valid_move
  pop bc
  jr c,.have_valid_move

    ; Check whether it's a roll up from the top row
    ; while the exit is open
    ld a,2  ; roll up
    xor c
    ret nz
    call check_exitable_cell
    ret nc

    ; Mark the level as exited
    ld b,b
    ld c,2
    call player_start_roll
    ld a,$FF
    ld [cursor_y],a
    ret
  .have_valid_move:

  push af
  push hl
  push de
  call player_start_roll
  pop de
  pop hl
  pop af

  ; A: 1 for color change (possibly scoring); 0 for not
  ; C: move attempted; E[5:3]: new Y; E[2:0]: new X;
  ; HL: pointer to destination cell
  or a
  jr z,.move_to_cell_e
    push de
    push hl

    ; Get which track bit corresponds to this move ID
    ld a,c
    and $03
     ld b,a
    inc b
    ld a,$08
    .shlloop:
      rla
      dec b
      jr nz,.shlloop
    ld b,a

    ; See if that track bit is set
    call floor_read_at_cursor
    ld a,[hl]
    cpl
    and b
    jr z,.already_have_track_bit
      or [hl]
      ld [hl],a
      ld hl,cur_score
      inc [hl]
      call prepare_hDrawCell
      call prepare_pctage
    .already_have_track_bit:
    pop hl
    pop de

    ; Mark as entered
    set 3,[hl]
  .move_to_cell_e:
  ld a,e
  rra
  rra
  rra
  and $07
  ld [cursor_y],a
  ld a,e
  and $07
  ld [cursor_x],a
  ret

Libbet_pb16:
  incbin "obj/gb/Libbet.chrgb.pb16"
