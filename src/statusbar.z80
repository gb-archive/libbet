include "src/hardware.inc"
include "src/global.inc"

SMALL_DIGIT_BASE equ $D0
STATUS_SLASH equ $F6
STATUS_BLANK equ $F7
BIG_DIGIT_BASE equ $E0
STATUS_PERCENT equ $F4
STATUSBAR_CHR_COUNT = 40

SMALL_SCORE_POS equ _SCRN0+32*17+14
PCTAGE_POS equ _SCRN0+32*16+9
DEBUGHEX_POS equ _SCRN0+32*17+0

section "debughex", WRAM0
debughex:: ds 2

section "load_statusbar", ROM0

;;
; Expands 1bpp tiles to shadowed 2bpp
load_statusbar_chr::
  ld de,bigdigits_chr
  ld hl,$8000 + SMALL_DIGIT_BASE * 16
  ld bc,(STATUSBAR_CHR_COUNT<<8)|$FF  ; B: tilecount; C: notlastbyte
  .byteloop:
    ; Plane 0 is thisbyte | ~lastbyte
    ld a,[de]
    or c
    ld [hl+],a
    ; Plane 1 is thisbyte
    ld a,[de]
    inc de
    ld [hl+],a
    rra
    cpl
    ld c,a
    ; 16 byte units
    ld a,l
    and $0F
    jr nz,.byteloop
    dec b
    jr nz,.byteloop
  ret

;;
; Draws the unchanging parts of the status bar and prepares the
; current score in Popslide buffer.
draw_statusbar_tilemap::

  if USE_DEBUGHEX
    ld hl,debughex
    ld a,$C0
    ld [hl+],a
    ld [hl],$DE
  endc

  ; Clear status bar to solid blank tiles
  ld hl,_SCRN0+32*16
  ld a,STATUS_BLANK
  ld c,32+20
  call memset_tiny
  ; HL is at end of status bar

  ; Draw percent sign
  ld a,STATUS_PERCENT
  ld [PCTAGE_POS+3],a
  inc a
  ld [PCTAGE_POS+35],a

  ; Draw a slash, then maximum score in decimal
  ld l,low(SMALL_SCORE_POS+2)
  ld a,STATUS_SLASH
  ld [hl+],a
  ld a,[max_score]
  call bcd8bit_baa
  ld c,a
  swap a
  and $0F
  or SMALL_DIGIT_BASE
  ld [hl+],a
  ld a,c
  and $0F
  or SMALL_DIGIT_BASE
  ld [hl+],a
  ; fall through

;;
; Draws the current score as percentage and number of tracks
; to Popslide buffer.
prepare_pctage::
  ld hl,popslide_used
  ld l,[hl]

  ; Write packet header for raw score
  ld a,low(SMALL_SCORE_POS)
  ld [hl+],a
  ld a,high(SMALL_SCORE_POS)
  ld [hl+],a
  ld a,1  ; h literal of 2
  ld [hl+],a
  inc hl

  ; Convert current score to decimal
  ld a,[cur_score]
  call bcd8bit_baa  ; tens and ones in A
  ld c,a
  swap a
  and $0F
  jr nz,.score_more_than_ten
    ld a,STATUS_BLANK-SMALL_DIGIT_BASE
  .score_more_than_ten:
  add SMALL_DIGIT_BASE
  ld [hl+],a
  ld a,c
  and $0F
  add SMALL_DIGIT_BASE
  ld [hl+],a

  ; Top line of percentage
  ld a,low(PCTAGE_POS)
  ld [hl+],a
  ld a,high(PCTAGE_POS)
  ld [hl+],a
  ld a,2
  ld [hl+],a

  ; Convert current score to decimal percentage
  ld a,[max_score]
  ld c,a
  ld a,[cur_score]
  cp c
  jr c,.not_100percent
    ld de,BIG_DIGIT_BASE * $101
    ld a,BIG_DIGIT_BASE + 2
    jr .have_pctage_tiles_ade
  .not_100percent:
    ld b,a
    call pctdigit
    add a
    jr nz,.pctage_tens_nonblank
      ld a, STATUS_BLANK-BIG_DIGIT_BASE
    .pctage_tens_nonblank:
     add BIG_DIGIT_BASE
    ld d,a
    push de
    call pctdigit
    pop de
    add a
    add BIG_DIGIT_BASE
    ld e,a
    ld a,STATUS_BLANK
  .have_pctage_tiles_ade:

  ld c,a
  ld [hl+],a
  cp STATUS_BLANK
  jr z,.hundreds_is_blank
    inc c
  .hundreds_is_blank:
  ld a,d
  ld [hl+],a
  cp STATUS_BLANK
  jr z,.tens_is_blank
    inc d
  .tens_is_blank:
  ld a,e
  ld [hl+],a
  inc e

  ; Write bottom row
  ld a,low(PCTAGE_POS + 32)
  ld [hl+],a
  ld a,high(PCTAGE_POS + 32)
  ld [hl+],a
  ld a,2
  ld [hl+],a
  ld a,c
  ld [hl+],a
  ld a,d
  ld [hl+],a
  ld a,e
  ld [hl+],a

  ld a,l
  ld [popslide_used],a
  ret

draw_debughex::
  if USE_DEBUGHEX
  ; Write the header
  ld hl,popslide_used
  ld l,[hl]
  ld a,low(DEBUGHEX_POS)
  ld [hl+],a
  ld a,high(DEBUGHEX_POS)
  ld [hl+],a
  ld a,3
  ld [hl+],a
  inc l

  ; Write 4 digits
  ld a,[debughex+0]
  call .wr1hex
  ld a,[debughex+1]
  call .wr1hex

  ld a,l
  ld [popslide_used],a
  ret

.wr1hex:
  ld b,a
  swap a
  call .wr1dig
  ld a,b
.wr1dig:
  and $0F
  or SMALL_DIGIT_BASE
  ld [hl+],a
  endc
  ret

section "bigdigits_chr", ROM0, align[3]
bigdigits_chr: incbin "obj/gb/bigdigits-h.chr1"
