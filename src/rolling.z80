include "src/hardware.inc"
include "src/global.inc"

section "rollingstate", WRAM0

roll_dx: ds 1
roll_x: ds 1
roll_dy: ds 1
roll_y: ds 1
roll_dz: ds 1
roll_z: ds 1
roll_frame: ds 1
roll_frame_cd: ds 1
cursor_facing:: ds 1

section "rolling", ROM0

FRLB_MOVE     equ 4
FRLB_JUMP     equ 5
FRLB_READY    equ 6
FRLB_KEEPROLL equ 7
FRLF_MOVE     equ %00010000
FRLF_JUMP     equ %00100000
FRLF_READY    equ %01000000
FRLF_KEEPROLL equ %10000000
FRHB_LAST     equ 7
FRHF_LAST     equ %10000000

Libbet_framelist:
  ; 7654 3210  Byte 0
  ; |||| ++++- Cel ID
  ; |||+------ Move on this frame
  ; ||+------- Set roll_dz at start of this frame
  ; |+-------- A move beginning with a tuck can begin here
  ; +--------- A continued roll can begin here
  ; 7654 3210  Byte 1
  ; ||++-++++- Duration
  ; |+-------- Unknown
  ; +--------- Return to 0 after this frame expires

  ; 0: Still
  db 0|FRLF_READY, 30|FRHF_LAST
frame_roll_begin:
  ; 1: Tuck toward rolling
  db 1, 4
frame_roll_continue:
  ; 2-9: Roll toward X
  db 2|FRLF_MOVE, 2
  db 3|FRLF_MOVE, 2
  db 4|FRLF_MOVE, 2
  db 5|FRLF_MOVE, 2
  db 6|FRLF_MOVE, 2
  db 7|FRLF_MOVE, 2
  db 8|FRLF_MOVE, 2
  db 9|FRLF_MOVE, 2
  ; 10: Untuck after roll
  db 2|FRLF_READY|FRLF_KEEPROLL, 30
  db 1|FRLF_READY|FRLF_KEEPROLL, 4|FRHF_LAST
frame_jump_begin:
  ; 12: Jump
  db 1, 2
  db 1|FRLF_MOVE, 2
  db 10|FRLF_MOVE|FRLF_JUMP, 3
  db 11|FRLF_MOVE, 8
  db 12|FRLF_MOVE, 8
  db 13|FRLF_MOVE, 7
  db 8|FRLF_MOVE, 2
  db 9|FRLF_MOVE, 2
  ; 19: Untuck after jump
  db 2|FRLF_READY|FRLF_KEEPROLL, 30
  db 1|FRLF_READY|FRLF_KEEPROLL, 4|FRHF_LAST

Libbet_facing_to_frame:
  dw $0E00, $0E20, $1C00, $0000

init_player_pos::
  xor a
  ld [roll_frame_cd],a
  ld [roll_frame],a
  ld a,2
  ld [cursor_facing],a
  ; fall through

set_roll_start_pos:
  ld a,[cursor_y]
  swap a
  ld d,a
  ld a,[floor_height]
  cp 8
  cpl  ; 2: FD+C; 4: FB+C; 6: F9+C; 7: F8+C; 8: F7+NC
  adc 9  ; 2: 7; 4: 5; 6: 3; 7: 2; 8: 0
  add a
  add a
  add a
  add d
  add 12
  ld [roll_y],a

  ld a,[cursor_x]
  swap a
  ld d,a
  ld a,[floor_width]
  cpl  ; 2: FD; 4: FB; 6: F9; 8: F7
  add 9  ; 2: 6; 4: 4; 6: 2; 7: 1; 8: 0
  add a
  add a
  add a
  add d
  add 24
  ld [roll_x],a

  xor a
  ld [roll_dx],a
  ld [roll_dy],a
  ld [roll_dz],a
  ld [roll_z],a
  ret

;;
; Set Z based on whether the animation is at a stopping point.
; @return ZF set for busy; clear for ok
; ADE clobbered; HL = frame properties
player_can_start_roll::
  ld a,[roll_frame]
  ld de,Libbet_framelist
  call de_index_a
  bit FRLB_READY,l
  ret

;;
; @param C roll direction
; @param cursor_x starting X position
; @param cursor_y starting Y position
; @return DE clobbered; HL = frame properties; A = frame length
player_start_roll::
  call set_roll_start_pos

  ; Set velocity
  ld a,c
  and MOVEF_DIRECTION
  ld de,movedirs
  call de_index_a
  ld a,l
  ld [roll_dx],a
  ld a,h
  ld [roll_dy],a

  ; Decide which frame sequence to use
  ld a,(frame_jump_begin - Libbet_framelist)/2
  bit MOVEB_JUMP,c
  jr nz,.have_frame
  ld a,(frame_roll_continue - Libbet_framelist)/2
  bit FRLB_KEEPROLL,l
  jr z,.have_frame
  dec a
.have_frame:
  ld [roll_frame],a
  ld de,Libbet_framelist
  call de_index_a
  ld a,h
  add a
  ld [roll_frame_cd],a
  ret

move_player_anim::
  ld a,[roll_frame]
  ld de,Libbet_framelist
  call de_index_a
  ; B: remaining duration
  ; L: move on this frame
  ; H: reset on zero

  ; Actual movement is at 30 fps
  ld a,[roll_frame_cd]
  ld b,a
  bit 0,b
  jr z,.no_move
  bit FRLB_MOVE,l
  jr z,.no_move
    ld a,[roll_dx]
    ld c,a
    ld a,[roll_x]
    add c
    ld [roll_x],a
    ld a,[roll_dy]
    ld c,a
    ld a,[roll_y]
    add c
    ld [roll_y],a

    ; Gravity
    ld a,[roll_dz]
    dec a
    ld [roll_dz],a
    ld c,a
    ld a,[roll_z]
    add c
    ; If bit 7 is set, has landed
    bit 7,a
    jr z,.no_land
      xor a
      ld [roll_dz],a
    .no_land:
    ld [roll_z],a
  .no_move:

  ld a,b
  dec a
  jr nz,.not_new_frame
    ; If the last frame, reset to frame A (which is 0)
    bit FRHB_LAST,h
    jr nz,.is_last_frame
      ld a,[roll_frame]
      inc a
    .is_last_frame:
    ld [roll_frame],a

    ; Jump if requested
    ld de,Libbet_framelist
    call de_index_a
    bit FRLB_JUMP,l
    jr z,.no_jump
      ld a,11
      ld [roll_dz],a
    .no_jump:

    ; Set duration of this frame
    ld a,h
    add a
  .not_new_frame:
  ld [roll_frame_cd],a
  ret

draw_player::
  ld a,[roll_x]
  ldh [hmsprXLo],a
  ld a,[roll_z]
  ld b,a
  or a
  rra
  add b
  and $F0
  swap a
  ld b,a
  ld a,[roll_y]
  sub b
  ldh [hmsprYLo],a

  ; Decide based on facing and frame list which cell to show
  ld a,[cursor_facing]
  ld de,Libbet_facing_to_frame
  call de_index_a
  ld a,l
  ldh [hmsprAttr],a
  ld b,h
  ld a,[roll_frame]
  ld de,Libbet_framelist
  call de_index_a
  ld a,$0F
  and l
  add b
  ldh [hmsprFrame],a
  xor a
  ldh [hmsprXHi],a
  ldh [hmsprYHi],a
  ld a,$00
  ldh [hmsprSheetID],a
  ldh [hmsprBaseTile],a
  call draw_metasprite

  ; If high enough, draw a shadow for depth
  ld a,[roll_z]
  cp 8
  jr c,.no_shadow
    ld a,42
    ldh [hmsprFrame],a
    ld a,[roll_x]
    ldh [hmsprXLo],a
    ld a,[roll_y]
    ldh [hmsprYLo],a
    xor a
    ldh [hmsprXHi],a
    ldh [hmsprYHi],a
    call draw_metasprite

  .no_shadow:

  ret
