;
; Background drawing for GB port of Magic Floor
;
; Copyright 2002, 2012 Martin Korth [concept]
; Copyright 2018, 2019 Damian Yerrick [program]
;
; This software is provided 'as-is', without any express or implied
; warranty.  In no event will the authors be held liable for any damages
; arising from the use of this software.
; 
; Permission is granted to anyone to use this software for any purpose,
; including commercial applications, and to alter it and redistribute it
; freely, subject to the following restrictions:
; 
; 1. The origin of this software must not be misrepresented; you must not
;    claim that you wrote the original software. If you use this software
;    in a product, an acknowledgment in the product documentation would be
;    appreciated but is not required.
; 2. Altered source versions must be plainly marked as such, and must not be
;    misrepresented as being the original software.
; 3. This notice may not be removed or altered from any source distribution.
;
include "src/hardware.inc"
include "src/global.inc"

section "floorupdate_wram",WRAM0
floor_top_row:: ds 1

section "load_floor_chr",ROM0

decomppos equ $9800-12*16
harrow_chr equ decomppos+8*16
varrow_chr equ decomppos+9*16
deadend_chr equ decomppos+10*16

;;
; Convert all pixels with color 2 to color 1, in place
; Useful to modify tiles for Super Game Boy colorization.
; @param HL source and destination
; @param B sliver count (e.g. 16 for two tiles)
; @return AC trashed, B=0
color2to1_if_sgb:
  ld a, [hw_capability]
  rra
  ret nc
color2to1:
  ld a, [hl+]
  ld c, a      ; E: plane 0
  ld a, [hl-]  ; A: plane 1
  or c
  ld [hl+], a
  ld a, [hl]   ; A: plane 1
  and c
  ld [hl+], a
  dec b
  jr nz, color2to1
  ret

;;
; Load the CHR 
load_floor_chr::
  ; Stage 1: Unpack
  ld de,floortiles_pb16
  ld hl,decomppos
  ld b,12
  call pb16_unpack_block

  ; If SGB, convert color 2 to color 1 in this tile
  ld hl, decomppos
  ld b, 16*3
  call color2to1_if_sgb

  ; Produce versions with horizontal arrow overlaid
  ld hl,decomppos
  ld de,CHRRAM2
  ld bc,$0004
  .colorloop:
    ; $9000-$90FF: Normal tile
    push bc
    push de  ; stack: start of this color in VRAM, colors left
    ld bc,32
    call memcpy
    pop de
    push hl  ; stack: next color src data, colors left
    ld h,d
    ld l,e
    inc d

    ; $9100-$91FF: Add horizontal arrows
    call add1harrow

    ; $9200-$92FF: Add vertical arrows
    ld bc,varrow_chr
    call add1arrow

    ; $9300-$93FF: Add vertical arrows to horizontal arrows
    ld h,d
    ld l,e
    dec h
    call add1harrow
    
    ; $9400-$94FF: Add holes
    ld h,$90
    push de
    ld bc,32
    call memcpy
    pop de
    ld hl,deadend_chr

    .addholeloop:
      ; load mask
      ld a,[hl+]  ; load andmask
      ld c,a
      ld a,[hl+]  ; load ormask
      ld b,a

      ; apply andmask to sliver 0
      ld a,[de]
      and c
      ld [de],a
      inc e

      ; apply andmask and ormask to sliver 1
      ld a,[de]
      and c
      or b
      ld [de],a
      inc de

      ld a,$1F
      and e
      jr nz,.addholeloop

    ; If SGB, convert the hole to color 1
    ld h, d
    ld l, e
    res 5, l
    ld b, 16
    call color2to1_if_sgb
    
    ; Move to next color
    ld hl,$9040-$9420
    add hl,de
    ld d,h
    ld e,l
    pop hl
    pop bc
    dec c
    jr nz,.colorloop

  ; Now generate the flipped tiles
  ld de,CHRRAM2
  ld hl,CHRRAM2+2*16
  ld c,$20
  .fliploop:
    .flipbyteloop:
      ld a,[de]
      inc de

      ; bitreverse
      ld b,a
      rlca          ; 6 5 4 3 2 1 0 7
      rlca          ; 5 4 3 2 1 0 7 6
      xor b         ; 7564534231201706
      and $55       ; __64__42__20__06
      xor b         ; 7 4 5 2 3 0 1 6
      ld b,a
      swap a        ; 3 0 1 6 7 4 5 2
      xor b         ; 7340512637041562
      and $66       ; __0415____0415__
      xor b         ; 7 0 1 2 3 4 5 6
      rlca          ; 0 1 2 3 4 5 6 7

      ld [hl+],a
      dec c
      jr nz,.flipbyteloop
    ld bc,$20
    ld d,h
    ld e,l
    add hl,bc
    ld a,h
    cp $95
    jr c,.fliploop

  ; Finish by loading the border tiles into the area where
  ; decompression was performed
  ld de,floorborder_pb16
  ld a, [hw_capability]
  rra
  jr nc, .border_not_sgb
    ld de, floorborder_sgb_pb16
  .border_not_sgb:

  ld hl,CHRRAM2+$6C*16
  ld b,20
  jp pb16_unpack_block

add1harrow:
  ld bc,harrow_chr
;;
; Overlays 1 arrow at BC and its vertical flip onto the data at HL
; forming 32 bytes at (16-byte aligned) DE.
; Advances DE by $0100 and leaves HL unchanged.
add1arrow:
  push hl
  push bc
  push de
  ld bc,32
  call memcpy
  pop de
  pop hl

  .downloop:
    ; load mask
    ld a,[hl+]  ; load andmask
    ld c,a
    ld a,[hl+]  ; load ormask
    ld b,a

    ; apply to sliver 0
    ld a,[de]
    and c
    or b
    ld [de],a
    inc e

    ; apply to sliver 1
    ld a,[de]
    and c
    or b
    ld [de],a
    inc de

    ld a,$0F
    and e
    jr nz,.downloop

  dec hl
  .uploop:  

    ; load mask
    ld a,[hl-]  ; load ormask
    ld b,a
    ld a,[hl-]  ; load andmask
    ld c,a

    ; apply andmask to sliver 0
    ld a,[de]
    and c
    or b
    ld [de],a
    inc e

    ; apply andmask and ormask to sliver 1
    ld a,[de]
    and c
    or b
    ld [de],a
    inc de

    ld a,$0F
    and e
    jr nz,.uploop

  ; Move destination to next arrow type
  ld a,224
  add e
  ld e,a
  jr nc,.noewrap
    inc d
  .noewrap:
  pop hl
  ret

section "floor_chr", ROM0
floortiles_pb16: incbin "obj/gb/floorpieces-h.chrgb.pb16"
floorborder_pb16: incbin "obj/gb/floorborder-h.chrgb.pb16"
floorborder_sgb_pb16: incbin "obj/gb/floorborder-sgb-h.chrgb.pb16"

; Drawing cells to tile map ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "floor_tilemap",ROM0

CELL_W = 2

;;
; Calculate the top row of the floor.  This is centered in the
; Game Boy screen, except at height 8 where it's 1 higher than
; expected because the back wall isn't drawn.
; Thus for floor heights 2, 3, 4, 5, 6, 7, 8, this is
; 7, 6, 5, 4, 3, 2, 0.

calc_floor_top_row::
  ; Calculate which tile row: A = y * 2 + 8 - height
  ld a,[floor_height]
  ; don't make room for back wall if already 8 cells tall
  cp 8
  jr nz,.notfullht
    inc a
  .notfullht:
  cpl
  add 9+1  ; A = 9 - height
  ld [floor_top_row],a
  ret

;;
; Sets HL to the tilemap address of the cursor
goto_tile_at_cursor:
  ld a,[cursor_y]
  ld d,a
  ld a,[cursor_x]
  ld e,a
  ; fall through

;;
; Sets HL to the tilemap address of cell (E, D)
; SCRN_BG + 32 * (y * 2 + top row) + (x * 2 + 10 - width)
; BCDE unchanged
goto_tile_e_d::
  ld a,[floor_top_row]
  add d
  add d

  ; fast mul by 32 to get which tile row
  swap a
  add a  ; save the carry!
  ld l,a
  ld a,high(SCRN_BG) >> 1
  rla
  ld h,a

  ; Seek to tile within row: A = x * 2 + 10 - width
  ld a,[floor_width]
  cpl
  add 10+1  ; A = 10 - width
  add e
  add e
  add l
  ld l,a
  ret

prepare_hDrawCell::
  call goto_tile_at_cursor
  ld d,h
  ld a,l

  ; Write first packet header to popslide_buf
  ld hl,popslide_used
  ld l,[hl]  ; now points into popslide_buf
  ld [hl+],a
  add 32
  ld e,a
  ld a,d
  ld [hl+],a
  jr nc,.noincde
    inc d
  .noincde:
  ld a,CELL_W - 1  ; 2 horizontal
  ld [hl+],a
  inc hl
  push de  ; Stack: bottom half address

  ; Find the shape
  push hl
  call floor_read_at_cursor
  pop hl
  ld b,a

  ; Calculate base tile ID (shades: 0, 4, 8, C; deadends: 40, 44, 48, 4C)
  add a
  add a
  ; If bits 2 (not round trip reachable) and 3 (entered) are both
  ; true, this is an entered dead end, drawn with tiles $40-$4F.
  ; Otherwise it's a regular cell, drawn with $00-$0F (plus arrows).
  if SHOW_UNENTERED_DEADENDS
    and $1C  ; save only deadend and shade bits
    add $30
  else
    and $3C  ; save only deadend, entered, and shade bits
    add $10
  endc
  and $4C

  ; construct 4 corners of tile
  ; E D
  ; C A
  ld e,a
  inc a
  ld c,a
  inc a
  ld d,a
  inc a

  ; Turn on tracks at sides of tiles
  bit 4,b
  jr z,.no_right_track
    set 4,d
    set 4,a
  .no_right_track:
  bit 5,b
  jr z,.no_left_track
    set 4,e
    set 4,c
  .no_left_track:
  bit 6,b
  jr z,.no_up_track
    set 5,e
    set 5,d
  .no_up_track:
  bit 7,b
  jr z,.no_down_track
    set 5,c
    set 5,a
  .no_down_track:
  ld b,a
  ld a,e
  ld [hl+],a
  ld a,d
  ld [hl+],a

  ; Write bottom row
  pop de
  ld a,e
  ld [hl+],a
  ld a,d
  ld [hl+],a
  ld a,CELL_W - 1
  ld [hl+],a
  inc hl
  ld a,c
  ld [hl+],a
  ld a,b
  ld [hl+],a
  ld a,l
  ld [popslide_used],a
  ret

gbc_prepare_cell_attr::
  call goto_tile_at_cursor
  ld d,h
  ld a,l

  ; Write first packet header to popslide_buf
  ld hl,popslide_used
  ld l,[hl]  ; now points into popslide_buf
  ld [hl+],a
  add 32
  ld e,a
  ld a,d
  ld [hl+],a
  jr nc,.noincde
    inc d
  .noincde:
  push de  ; Stack: bottom half address

  ld a,CELL_W  + 63  ; 2 horizontal
  ld [hl+],a
  push hl
  call floor_read_at_cursor
  pop hl
  and $03  ; A = color

  ; Calculate attribute: 1, 0, 2, 0
  rra    ; 0 0 1 1
  inc a  ; 1 1 2 2
  jr nc, .notgray
    xor a
  .notgray:
  ld [hl+], a
  ld b, a
  
  ; Bottom half same
  pop de
  ld a, e
  ld [hl+], a
  ld a, d
  ld [hl+], a
  ld a, CELL_W  + 63  ; 2 horizontal
  ld [hl+], a
  ld a, b
  ld [hl+], a

  ; Save new pointer
  ld a,l
  ld [popslide_used],a
  ret

draw_whole_floor::
  xor a
  .rowloop:
    ld [cursor_y],a

    ; Fill Popslide buffer with a row of cells
    xor a
    .tileloop:
      ld [cursor_x],a
      call prepare_hDrawCell
      ld a,[floor_width]
      ld b,a
      ld a,[cursor_x]
      inc a
      cp b
      jr nz,.tileloop
    call popslide_terminate_blit
    
    ld a, [initial_a]
    cp $11
    jr nz, .notGBC
      ld [rVBK], a
      xor a
      .attrloop:
        ld [cursor_x],a
        call gbc_prepare_cell_attr
        ld a,[floor_width]
        ld b,a
        ld a,[cursor_x]
        inc a
        cp b
        jr nz,.attrloop
      call popslide_terminate_blit
      xor a
      ld [rVBK], a
    .notGBC:

    ; And move to the next row
    ld a,[floor_height]
    ld b,a
    ld a,[cursor_y]
    inc a
    cp b
    jr nz,.rowloop
  ret

;;
; Forms an attribute map for Super Game Boy in lineImgBuf
sgb_form_floor_attr::
  ; Clear the background to 0
  ld hl, lineImgBuf
  ld [hl], $07*8+6  ; ATTR_CHR, packet count
  inc hl
  xor a
  ld [hl+], a        ; starting X: 0
  ld [hl+], a        ; starting Y: 0
  ld [hl], low(360)  ; number of 2-bit attributes
  inc hl
  ld [hl], high(360)
  inc hl
  ld [hl+], a        ; row major
  ld d, a
  push hl            ; Stack: address of top of attribute table
  cpl                ; color 3 for out-of-bounds tiles
  ld c, 90
  call memset_tiny

  ld a, [floor_top_row]
  ld b, a
  add a
  add a
  add b
  ld e, a     ; DE: offset of first row within attribute table
  pop hl
  add hl, de  ; HL: offset of first nonborder row in attribute table
  ld de, floor_map
  ld a, [floor_height]
  ld b, a

  .rowloop:
    ; Regmap now:
    ; B: remaining floor rows
    ; DE: pointer into floor_map
    ; HL: destination
    push bc
    push de
    push hl
    ; Stack: destination row start, floor map row start, remaining floor row count
    ld b, 1  ; B is a circular buffer to collect bits
    call .writelrborder

    ; Write attributes for floor cells
    ld a, [floor_width]
    ld c, a
    .tileloop:
      ld a, [de]
      inc de
      and $03

      ; Calculate attribute: 1, 0, 2, 0
      rra    ; 0 0 1 1
      inc a  ; 1 1 2 2
      jr nc, .notgray
        xor a
      .notgray:
      call .write2bits
      call .write2bits
      dec c
      jr nz, .tileloop
    call .writelrborder
  ld b, b

    ; Duplicate the attribute row
    pop de
    ld c, 5
    .cpy:
      ld a, [de]
      ld [hl+], a
      inc de
      dec c
      jr nz, .cpy

    ; move to next row of floor
    pop de
    ld a, e
    or 7
    ld e, a
    inc de
    pop bc
    dec b
    jr nz, .rowloop
  ret

.writelrborder:
  ld a, [floor_width]
  cpl
  sub (255 - 10)
  ld c, a
  ld a, 3
.write2bitstimesC:
  call .write2bits
  dec c
  jr nz, .write2bitstimesC
  ret
.write2bits:
  rrca   ; A: a:aXXXXXXb
  rrca   ; A: b:baXXXXXX
  rlca   ; A: b:aXXXXXXb
  rl b
  rlca   ; A: a:XXXXXXba
  rl b
  ret nc
  ld [hl], b
  inc hl
  ld b, 1
  ret

draw_floor_border::
  ld a,[floor_height]
  cp 8
  jr nc,.no_back_wall
    ; Bottom row
    ld bc,($71 << 8)|(-33 & $FF)
    call .do_one_top_row
    ; Top row
    ld bc,($70 << 8)|(-65 & $FF)
    call .do_one_top_row
  .no_back_wall:

  ; Left wall
  ld de,0
  call goto_tile_e_d
  dec hl
  ld a,[floor_height]
  ld c,a
  ld a,$77
  call .do_one_side_wall

  ld a,[floor_width]
  ld e,a
  call goto_tile_e_d
  ld a,$76
  ; fall through

;;
; @param HL top tile address
; @param C height in tile pairs
; @param A tile ID
.do_one_side_wall:
  push af
  ld a, [initial_a]
  cp $11
  jr nz, .side_notGBC
    ldh [rVBK], a
    push bc
    push hl
    ld a, 3  ; walls palette
    call .do_one_side_wall_plane
    pop hl
    pop bc
    xor a
    ldh [rVBK], a
  .side_notGBC:
  pop af
.do_one_side_wall_plane:
  ld b,c
  ld de,32
  .sidewallloop:
    ld [hl],a
    add hl,de
    ld [hl],a
    add hl,de
    dec b
    jr nz,.sidewallloop
  ret

;;
; @param B top left tile ID
; @param C signed amount to add to HL: -33 or -65
.do_one_top_row:
  ld de,0
  call goto_tile_e_d
  dec d
  ld e,c
  add hl,de

  ld a, [initial_a]
  cp $11
  jr nz, .toprow_notGBC
    ldh [rVBK], a
    push hl
    ld a, [floor_width]
    inc a
    add a
    ld c, a
    ld a, 3  ; walls palette
    call memset_tiny
    pop hl
    xor a
    ldh [rVBK], a
  .toprow_notGBC:

  ; Top left corner
  ld a,b
  ld [hl+],a
  ; Body of top
  ld a,[floor_width]
  ld c,a
  ld a,b
  add 2
  .toprowloop:
    ld [hl+],a
    ld [hl+],a
    dec c
    jr nz,.toprowloop
  ; Top right corner
  ld a,b
  add 4
  ld [hl+],a
  ret

; Exit indication ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

prepare_exit_door::
  ; Only maps not taller than 8 cells have an exit door.
  ; For taller maps, all the top cells are exits, and arrows
  ; at the top indicate that the exit is open.
  ld a,[floor_height]
  cp 8
  jr nc,prepare_exit_arrows

  ; Door is drawn 2 cells above exit cell
  ld d,0
  ld a,[exit_x]
  ld e,a
  call goto_tile_e_d
  ld de,-32*2
  add hl,de
  ld d,h
  ld a,l

  ; Form top row packet
  ld hl,popslide_used
  ld l,[hl]
  ld [hl+],a
  add 32
  ld e,a
  ld a,d
  ld [hl+],a
  jr nc,.noewrap
    inc d
  .noewrap:
  ld a,CELL_W - 1
  ld [hl+],a
  inc hl

  ; Closed  Open
  ; 78 7A   7C 7E
  ; 79 7B   7D 7F
  ld a,[exit_open]
  or a
  ld a,$78
  jr z,.use_open_tile
    ld a,$7C
  .use_open_tile:
  ld [hl+],a
  add 2
  ld [hl+],a
  dec a
  ld b,a

  ; Second row
  ld a,e
  ld [hl+],a
  ld a,d
  ld [hl+],a
  ld a,CELL_W - 1
  ld [hl+],a
  inc hl
  ld a,b
  ld [hl+],a
  add 2
  ld [hl+],a
  ld a,l
  ld [popslide_used],a
  ret

prepare_exit_arrows:
  ld a,[exit_open]
  or a
  ret z
  ld de,0
  call goto_tile_e_d
  ld d,h
  ld e,l
  ld hl,popslide_used
  ld l,[hl]

  ; Draw arrow on left
  ld a,e
  sub 2
  ld [hl+],a
  ld a,d
  ld [hl+],a
  xor a  ; $00: 1 byte
  ld [hl+],a
  ld a,$6E  ; arrow tile
  ld [hl+],a

  ; Draw arrow on right
  ld a,[floor_width]
  add a
  inc a
  add e
  ld [hl+],a
  ld a,d
  ld [hl+],a
  xor a
  ld [hl+],a
  ld a,$6E  ; arrow tile
  ld [hl+],a

  ld a,l
  ld [popslide_used],a
  ret
